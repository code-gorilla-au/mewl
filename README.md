<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mewl

```go
import "github.com/code-gorilla-au/mewl"
```

## Index

- [func Chunk[T any](list []T, chunkSize int) [][]T](<#func-chunk>)
- [func Difference[T comparable](lists ...[]T) []T](<#func-difference>)
- [func Every[T any](list []T, fn PredicateFunc[T]) bool](<#func-every>)
- [func Filter[T any](list []T, fn PredicateFunc[T]) []T](<#func-filter>)
- [func Find[T any](list []T, fn PredicateFunc[T]) (T, bool)](<#func-find>)
- [func ForEach[T comparable](list []T, fn func(input T))](<#func-foreach>)
- [func Map[T comparable, K any](list []T, fn MapperFunc[T, K]) []K](<#func-map>)
- [func Reverse[T comparable](list []T) []T](<#func-reverse>)
- [func Union[T comparable](lists ...[]T) []T](<#func-union>)
- [func Unique[T comparable](list []T) []T](<#func-unique>)
- [func Without[T comparable](list []T, omit ...T) []T](<#func-without>)
- [type ComposeFunc](<#type-composefunc>)
  - [func Once[T any](fn ComposeFunc[T]) ComposeFunc[T]](<#func-once>)
  - [func Pipe[T any](fns ...ComposeFunc[T]) ComposeFunc[T]](<#func-pipe>)
  - [func Reduce[T any](list []T, fn func(prev T, next T) T) ComposeFunc[T]](<#func-reduce>)
- [type MapperFunc](<#type-mapperfunc>)
- [type PredicateFunc](<#type-predicatefunc>)


## func [Chunk](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L114>)

```go
func Chunk[T any](list []T, chunkSize int) [][]T
```

Chunk \- creates a new nested slice with slice elements chunked

## func [Difference](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L129>)

```go
func Difference[T comparable](lists ...[]T) []T
```

Difference \- Creates an array of array values not included in the other given arrays.

## func [Every](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L81>)

```go
func Every[T any](list []T, fn PredicateFunc[T]) bool
```

Every \- tests whether all elements in the array pass the test implemented by the provided function.

## func [Filter](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L4>)

```go
func Filter[T any](list []T, fn PredicateFunc[T]) []T
```

Filter \- return a new list of elements that return true on the predicate func.

## func [Find](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L69>)

```go
func Find[T any](list []T, fn PredicateFunc[T]) (T, bool)
```

Find \- returns the first element in the provided array that satisfies the provided testing function. If item is not found return nil value.

## func [ForEach](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L26>)

```go
func ForEach[T comparable](list []T, fn func(input T))
```

ForEach \- iterates over the list and invokes the function on the element.

## func [Map](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L16>)

```go
func Map[T comparable, K any](list []T, fn MapperFunc[T, K]) []K
```

Map \- creates a new array populated with the results of calling a provided function on every element in the calling array.

## func [Reverse](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L105>)

```go
func Reverse[T comparable](list []T) []T
```

Reverse \- return slice in reverse order

## func [Union](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L49>)

```go
func Union[T comparable](lists ...[]T) []T
```

Union \- merges two lists into a slice with no duplicates composed of the elements of each list.

## func [Unique](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L33>)

```go
func Unique[T comparable](list []T) []T
```

Unique \- return unique items from a provided list

## func [Without](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L158>)

```go
func Without[T comparable](list []T, omit ...T) []T
```

Without \- Creates an array excluding all given values

## type [ComposeFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L4>)

ComposeFunc \- function that receives an input and returns an input of the same type.

```go
type ComposeFunc[T any] func(T) T
```

### func [Once](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L16>)

```go
func Once[T any](fn ComposeFunc[T]) ComposeFunc[T]
```

Once \- Creates a function that is restricted to invoking func once. Repeat calls to the function return the value of the first invocation

### func [Pipe](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L4>)

```go
func Pipe[T any](fns ...ComposeFunc[T]) ComposeFunc[T]
```

Pipe \- left to right function composition

### func [Reduce](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L94>)

```go
func Reduce[T any](list []T, fn func(prev T, next T) T) ComposeFunc[T]
```

Reduce \- executes a user\-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value

## type [MapperFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L10>)

MapperFunc \- transform function that receives an input and returns a new type.

```go
type MapperFunc[T any, K any] func(item T) K
```

## type [PredicateFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L7>)

PredicateFunc \- function that receives an input and returns a boolean value.

```go
type PredicateFunc[T any] func(item T) bool
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->