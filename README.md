<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mewl

```go
import "github.com/code-gorilla-au/mewl"
```

## Index

- [func Chunk\[T any\]\(list \[\]T, chunkSize int\) \[\]\[\]T](<#Chunk>)
- [func Difference\[T comparable\]\(lists ...\[\]T\) \[\]T](<#Difference>)
- [func Every\[T any\]\(list \[\]T, fn PredicateSliceFunc\[T\]\) bool](<#Every>)
- [func Filter\[T any\]\(list \[\]T, fn PredicateFunc\[T\]\) \[\]T](<#Filter>)
- [func Find\[T any\]\(list \[\]T, fn PredicateSliceFunc\[T\]\) \(T, bool\)](<#Find>)
- [func ForEach\[T comparable\]\(list \[\]T, fn CallbackSliceFunc\[T\]\)](<#ForEach>)
- [func Map\[T comparable, K any\]\(list \[\]T, fn MapperFunc\[T, K\]\) \[\]K](<#Map>)
- [func MapClone\[T comparable, K any\]\(obj map\[T\]K\) map\[T\]K](<#MapClone>)
- [func MapKeys\[T comparable, K any\]\(obj map\[T\]K\) \[\]T](<#MapKeys>)
- [func MapOmitBy\[T comparable, K any\]\(obj map\[T\]K, fn PredicateFunc\[K\]\) map\[T\]K](<#MapOmitBy>)
- [func MapOmitKeys\[T comparable, K any\]\(obj map\[T\]K, omits ...T\) map\[T\]K](<#MapOmitKeys>)
- [func MapPickBy\[T comparable, K any\]\(obj map\[T\]K, fn PredicateFunc\[K\]\) map\[T\]K](<#MapPickBy>)
- [func MapPickKeys\[T comparable, K any\]\(obj map\[T\]K, picks ...T\) map\[T\]K](<#MapPickKeys>)
- [func MapValues\[T comparable, K any\]\(obj map\[T\]K\) \[\]K](<#MapValues>)
- [func Reverse\[T comparable\]\(list \[\]T\) \[\]T](<#Reverse>)
- [func Some\[T any\]\(list \[\]T, fn PredicateSliceFunc\[T\]\) bool](<#Some>)
- [func Union\[T comparable\]\(lists ...\[\]T\) \[\]T](<#Union>)
- [func Unique\[T comparable\]\(list \[\]T\) \[\]T](<#Unique>)
- [func Without\[T comparable\]\(list \[\]T, omit ...T\) \[\]T](<#Without>)
- [type AnyFunc](<#AnyFunc>)
  - [func Before\[T any\]\(n int, fn AnyFunc\[T\]\) AnyFunc\[T\]](<#Before>)
- [type CallbackSliceFunc](<#CallbackSliceFunc>)
- [type ComposeFunc](<#ComposeFunc>)
  - [func Once\[T any\]\(fn ComposeFunc\[T\]\) ComposeFunc\[T\]](<#Once>)
  - [func Pipe\[T any\]\(fns ...ComposeFunc\[T\]\) ComposeFunc\[T\]](<#Pipe>)
  - [func Reduce\[T any\]\(list \[\]T, fn func\(prev T, next T\) T\) ComposeFunc\[T\]](<#Reduce>)
- [type MapperFunc](<#MapperFunc>)
- [type PredicateFunc](<#PredicateFunc>)
- [type PredicateSliceFunc](<#PredicateSliceFunc>)
- [type Txn](<#Txn>)
  - [func NewTxn\[T any\]\(state T\) \*Txn\[T\]](<#NewTxn>)
  - [func \(t \*Txn\[T\]\) Run\(\) \(T, error\)](<#Txn[T].Run>)
  - [func \(t \*Txn\[T\]\) Step\(handler TxnFunc\[T\], rollback TxnFunc\[T\]\) \*Txn\[T\]](<#Txn[T].Step>)
- [type TxnFunc](<#TxnFunc>)
- [type TxnState](<#TxnState>)
- [type TxnStep](<#TxnStep>)


<a name="Chunk"></a>
## func [Chunk](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L114>)

```go
func Chunk[T any](list []T, chunkSize int) [][]T
```

Chunk \- creates a new nested slice with slice elements chunked

<details><summary>Example</summary>
<p>



```go
list := []int{1, 2, 3, 4, 5, 6}

got := Chunk(list, 2)

fmt.Println(got)
// Output: [[1 2] [3 4] [5 6]]
```

#### Output

```
[[1 2] [3 4] [5 6]]
```

</p>
</details>

<a name="Difference"></a>
## func [Difference](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L129>)

```go
func Difference[T comparable](lists ...[]T) []T
```

Difference \- Creates an array of array values not included in the other given arrays.

<details><summary>Example</summary>
<p>



```go
list1 := []int{1, 2, 3}
list2 := []int{2, 3, 4}
got := Difference(list1, list2)

fmt.Println(got)
// Output: [1 4]
```

#### Output

```
[1 4]
```

</p>
</details>

<a name="Every"></a>
## func [Every](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L81>)

```go
func Every[T any](list []T, fn PredicateSliceFunc[T]) bool
```

Every \- tests whether all elements in the array pass the test implemented by the provided function.

<details><summary>Example</summary>
<p>



```go
list := []KeyVal{
	{
		Key:   "foo",
		Value: "bar",
	},
	{
		Key:   "bin",
		Value: "baz",
	},
}
// Note: the original slice is passed into the predicate function
ok := Every(list, func(item KeyVal, i int, originalSlice []KeyVal) bool {
	return item.Value != ""
})

fmt.Println(ok)
// Output: true
```

#### Output

```
true
```

</p>
</details>

<a name="Filter"></a>
## func [Filter](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L4>)

```go
func Filter[T any](list []T, fn PredicateFunc[T]) []T
```

Filter \- return a new list of elements that return true on the predicate func.

<details><summary>Example</summary>
<p>



```go
list := []KeyVal{
	{
		Key:   "foo",
		Value: "bar",
	},
	{
		Key:   "bin",
		Value: "baz",
	},
}

got := Filter(list, func(item KeyVal) bool {
	return item.Key == "foo"
})
fmt.Println(got)
// Output: [{foo bar}]
```

#### Output

```
[{foo bar}]
```

</p>
</details>

<a name="Find"></a>
## func [Find](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L69>)

```go
func Find[T any](list []T, fn PredicateSliceFunc[T]) (T, bool)
```

Find \- returns the first element in the provided array that satisfies the provided testing function. If item is not found return nil value.

<details><summary>Example</summary>
<p>



```go
list := []KeyVal{
	{
		Key:   "foo",
		Value: "bar",
	},
	{
		Key:   "bin",
		Value: "baz",
	},
}

got, ok := Find(list, func(item KeyVal, _ int, _ []KeyVal) bool {
	return item.Value == "bar"
})
fmt.Println(got, ok)
// Output: {foo bar} true
```

#### Output

```
{foo bar} true
```

</p>
</details>

<a name="ForEach"></a>
## func [ForEach](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L26>)

```go
func ForEach[T comparable](list []T, fn CallbackSliceFunc[T])
```

ForEach \- iterates over the list and invokes the function on the element.

<details><summary>Example</summary>
<p>



```go
list := []int{1, 1, 2}

total := 0

ForEach(list, func(item int, _ int, _ []int) {
	total += item
})

fmt.Println(total)
// Output: 4
```

#### Output

```
4
```

</p>
</details>

<a name="Map"></a>
## func [Map](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L16>)

```go
func Map[T comparable, K any](list []T, fn MapperFunc[T, K]) []K
```

Map \- creates a new array populated with the results of calling a provided function on every element in the calling array.

<details><summary>Example</summary>
<p>



```go
list := []KeyVal{
	{
		Key:   "foo",
		Value: "bar",
	},
	{
		Key:   "bin",
		Value: "baz",
	},
}

got := Map(list, func(item KeyVal) Val {
	return Val{
		Value: item.Value,
	}
})

fmt.Println(got)
// Output: [{bar} {baz}]
```

#### Output

```
[{bar} {baz}]
```

</p>
</details>

<a name="MapClone"></a>
## func [MapClone](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L6>)

```go
func MapClone[T comparable, K any](obj map[T]K) map[T]K
```

MapClone clones provided map

<details><summary>Example</summary>
<p>



```go
obj := map[string]int{
	"hello": 1,
	"world": 2,
}
got := MapClone(obj)

fmt.Println(got)
// Output: map[hello:1 world:2]
```

#### Output

```
map[hello:1 world:2]
```

</p>
</details>

<a name="MapKeys"></a>
## func [MapKeys](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L15>)

```go
func MapKeys[T comparable, K any](obj map[T]K) []T
```

Keys \- return map's keys

<details><summary>Example</summary>
<p>



```go
obj := map[int]string{
	1: "1",
	2: "flash",
}

got := MapKeys(obj)
sort.Ints(got)

fmt.Println(got)
// Output: [1 2]
```

#### Output

```
[1 2]
```

</p>
</details>

<a name="MapOmitBy"></a>
## func [MapOmitBy](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L48>)

```go
func MapOmitBy[T comparable, K any](obj map[T]K, fn PredicateFunc[K]) map[T]K
```

MapOmitBy \- returns a partial copy of an object omitting values based on a predicate func.

<details><summary>Example</summary>
<p>



```go
obj := map[string]int{
	"hello": 1,
	"world": 2,
}
got := MapOmitBy(obj, func(item int) bool {
	return item == 1
})

fmt.Println(got)
// Output: map[world:2]
```

#### Output

```
map[world:2]
```

</p>
</details>

<a name="MapOmitKeys"></a>
## func [MapOmitKeys](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L34>)

```go
func MapOmitKeys[T comparable, K any](obj map[T]K, omits ...T) map[T]K
```

MapOmitKeys \- returns a partial copy of an object omitting the keys specified. If the key does not exist, the property is ignored.

<details><summary>Example</summary>
<p>



```go
obj := map[string]int{
	"hello": 1,
	"world": 2,
	"bin":   3,
}

got := MapOmitKeys(obj, "hello", "world")

fmt.Println(got)
// Output: map[bin:3]
```

#### Output

```
map[bin:3]
```

</p>
</details>

<a name="MapPickBy"></a>
## func [MapPickBy](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L74>)

```go
func MapPickBy[T comparable, K any](obj map[T]K, fn PredicateFunc[K]) map[T]K
```

MapPickKeys\- Returns a partial copy of an object containing only the keys specified by a predicate func.

<details><summary>Example</summary>
<p>



```go
obj := map[string]int{
	"hello": 1,
	"world": 2,
}
got := MapPickBy(obj, func(item int) bool {
	return item == 1
})

fmt.Println(got)
// Output: map[hello:1]
```

#### Output

```
map[hello:1]
```

</p>
</details>

<a name="MapPickKeys"></a>
## func [MapPickKeys](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L61>)

```go
func MapPickKeys[T comparable, K any](obj map[T]K, picks ...T) map[T]K
```

MapPickKeys\- Returns a partial copy of an object containing only the keys specified. If the key does not exist, the property is ignored.

<details><summary>Example</summary>
<p>



```go
obj := map[int]string{
	1: "hello",
	2: "world",
	3: "bin",
}

got := MapPickKeys(obj, 1)

fmt.Println(got)
// Output: map[1:hello]
```

#### Output

```
map[1:hello]
```

</p>
</details>

<a name="MapValues"></a>
## func [MapValues](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L24>)

```go
func MapValues[T comparable, K any](obj map[T]K) []K
```

MapValues \- return map's values

<details><summary>Example</summary>
<p>



```go
obj := map[int]string{
	1: "hello",
	2: "world",
}

got := MapValues(obj)
sort.Strings(got)

fmt.Println(got)
// Output: [hello world]
```

#### Output

```
[hello world]
```

</p>
</details>

<a name="Reverse"></a>
## func [Reverse](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L105>)

```go
func Reverse[T comparable](list []T) []T
```

Reverse \- return slice in reverse order

<details><summary>Example</summary>
<p>



```go
list := []int{1, 2, 3}

got := Reverse(list)

fmt.Println(got)
// Output: [3 2 1]
```

#### Output

```
[3 2 1]
```

</p>
</details>

<a name="Some"></a>
## func [Some](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L174>)

```go
func Some[T any](list []T, fn PredicateSliceFunc[T]) bool
```

Some \- Checks if predicate returns truthy for any element of a list. Iteration is stopped once predicate returns truthy

<details><summary>Example</summary>
<p>



```go
list := []int{1, 2, 3}

got := Some(list, func(item, index int, slice []int) bool {
	return item == 2
})

fmt.Println(got)
// Output: true
```

#### Output

```
true
```

</p>
</details>

<a name="Union"></a>
## func [Union](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L49>)

```go
func Union[T comparable](lists ...[]T) []T
```

Union \- merges two lists into a slice with no duplicates composed of the elements of each list.

<details><summary>Example</summary>
<p>



```go
id := "1"
value := "some value"
lists := [][]KeyVal{
	{
		{
			Key:   id,
			Value: value,
		},
	},
	{
		{
			Key:   id,
			Value: value,
		},
	},
}

got := Union(lists...)

fmt.Println(got)
// Output: [{1 some value}]
```

#### Output

```
[{1 some value}]
```

</p>
</details>

<a name="Unique"></a>
## func [Unique](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L33>)

```go
func Unique[T comparable](list []T) []T
```

Unique \- return unique items from a provided list

<details><summary>Example</summary>
<p>



```go
list := []KeyVal{
	{
		Key:   "foo",
		Value: "bar",
	},
	{
		Key:   "foo",
		Value: "bar",
	},
	{
		Key:   "bin",
		Value: "baz",
	},
}

got := Unique(list)

fmt.Println(got)
// Output: [{foo bar} {bin baz}]
```

#### Output

```
[{foo bar} {bin baz}]
```

</p>
</details>

<a name="Without"></a>
## func [Without](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L158>)

```go
func Without[T comparable](list []T, omit ...T) []T
```

Without \- Creates an array excluding all given values

<details><summary>Example</summary>
<p>



```go
list := []KeyVal{
	{Key: "foo", Value: "bar"},
	{Key: "bin", Value: "baz"},
}

got := Without(list, KeyVal{Key: "bin", Value: "baz"})

fmt.Println(got)
// Output: [{foo bar}]
```

#### Output

```
[{foo bar}]
```

</p>
</details>

<a name="AnyFunc"></a>
## type [AnyFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L19>)

AnyFunc \- function that receives n arguments

```go
type AnyFunc[T any] func(args ...T) T
```

<a name="Before"></a>
### func [Before](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L32>)

```go
func Before[T any](n int, fn AnyFunc[T]) AnyFunc[T]
```

Creates a function that invokes func while it's called less than n times. Subsequent calls to the created function return the result of the last func invocation.

<a name="CallbackSliceFunc"></a>
## type [CallbackSliceFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L7>)

CallbackSliceFunc \- function that receives an index of the current item, current item being iterated on and the array Every was called upon.

```go
type CallbackSliceFunc[T any] func(item T, index int, slice []T)
```

<a name="ComposeFunc"></a>
## type [ComposeFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L4>)

ComposeFunc \- function that receives an input and returns an input of the same type.

```go
type ComposeFunc[T any] func(T) T
```

<a name="Once"></a>
### func [Once](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L16>)

```go
func Once[T any](fn ComposeFunc[T]) ComposeFunc[T]
```

Once \- Creates a function that is restricted to invoking func once. Repeat calls to the function return the value of the first invocation

<a name="Pipe"></a>
### func [Pipe](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L4>)

```go
func Pipe[T any](fns ...ComposeFunc[T]) ComposeFunc[T]
```

Pipe \- left to right function composition

<a name="Reduce"></a>
### func [Reduce](<https://github.com/code-gorilla-au/mewl/blob/main/slices.go#L94>)

```go
func Reduce[T any](list []T, fn func(prev T, next T) T) ComposeFunc[T]
```

Reduce \- executes a user\-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value

<details><summary>Example</summary>
<p>



```go
list := []int{1, 2, 3}

add := Reduce(list, func(prev, current int) int {
	return prev + current
})

got := add(1)

fmt.Println(got)
// Output: 7
```

#### Output

```
7
```

</p>
</details>

<a name="MapperFunc"></a>
## type [MapperFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L16>)

MapperFunc \- transform function that receives an input and returns a new type.

```go
type MapperFunc[T any, K any] func(item T) K
```

<a name="PredicateFunc"></a>
## type [PredicateFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L10>)

PredicateFunc \- function that receives an input and returns a boolean value.

```go
type PredicateFunc[T any] func(item T) bool
```

<a name="PredicateSliceFunc"></a>
## type [PredicateSliceFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L13>)

PredicateSliceFunc \- function that receives an index of the current item, current item being iterated on and the array Every was called upon.

```go
type PredicateSliceFunc[T any] func(item T, index int, slice []T) bool
```

<a name="Txn"></a>
## type [Txn](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L8-L13>)



```go
type Txn[T any] struct {
    Steps []TxnStep[T]
    // contains filtered or unexported fields
}
```

<a name="NewTxn"></a>
### func [NewTxn](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L28>)

```go
func NewTxn[T any](state T) *Txn[T]
```

NewTxn \- creates a new transaction.

<a name="Txn[T].Run"></a>
### func \(\*Txn\[T\]\) [Run](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L48>)

```go
func (t *Txn[T]) Run() (T, error)
```

Errors caught within the steps and rollback funcs will be able to be unwrapped and inspected using Unwrap\(\) \[\]error.

<a name="Txn[T].Step"></a>
### func \(\*Txn\[T\]\) [Step](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L39>)

```go
func (t *Txn[T]) Step(handler TxnFunc[T], rollback TxnFunc[T]) *Txn[T]
```

Step \- adds a step to the transaction workflow. All steps must have a handler and a rollback func.

<a name="TxnFunc"></a>
## type [TxnFunc](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L20>)



```go
type TxnFunc[T any] func(T) (T, error)
```

<a name="TxnState"></a>
## type [TxnState](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L15-L18>)



```go
type TxnState[T any] struct {
    // contains filtered or unexported fields
}
```

<a name="TxnStep"></a>
## type [TxnStep](<https://github.com/code-gorilla-au/mewl/blob/main/transactions.go#L22-L25>)



```go
type TxnStep[T any] struct {
    // contains filtered or unexported fields
}
```

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->