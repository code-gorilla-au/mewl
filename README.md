<!-- gomarkdoc:embed:start -->

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# mewl

```go
import "github.com/code-gorilla-au/mewl"
```

## Index

- [func Chunk[T any](list []T, chunkSize int) [][]T](<#func-chunk>)
- [func Difference[T comparable](lists ...[]T) []T](<#func-difference>)
- [func Every[T any](list []T, fn PredicateFunc[T]) bool](<#func-every>)
- [func Filter[T any](list []T, fn PredicateFunc[T]) []T](<#func-filter>)
- [func Find[T any](list []T, fn PredicateFunc[T]) (T, bool)](<#func-find>)
- [func ForEach[T comparable](list []T, fn func(input T))](<#func-foreach>)
- [func Map[T comparable, K any](list []T, fn MapperFunc[T, K]) []K](<#func-map>)
- [func MapKeys[T comparable, K any](obj map[T]K) []T](<#func-mapkeys>)
- [func MapOmitKeys[T comparable, K any](obj map[T]K, omits ...T) map[T]K](<#func-mapomitkeys>)
- [func MapPickKeys[T comparable, K any](obj map[T]K, picks ...T) map[T]K](<#func-mappickkeys>)
- [func MapValues[T comparable, K any](obj map[T]K) []K](<#func-mapvalues>)
- [func Reverse[T comparable](list []T) []T](<#func-reverse>)
- [func Some[T any](list []T, fn PredicateFunc[T]) bool](<#func-some>)
- [func Union[T comparable](lists ...[]T) []T](<#func-union>)
- [func Unique[T comparable](list []T) []T](<#func-unique>)
- [func Without[T comparable](list []T, omit ...T) []T](<#func-without>)
- [type ComposeFunc](<#type-composefunc>)
  - [func Before[T any](count int, fn ComposeFunc[T]) ComposeFunc[T]](<#func-before>)
  - [func Once[T any](fn ComposeFunc[T]) ComposeFunc[T]](<#func-once>)
  - [func Pipe[T any](fns ...ComposeFunc[T]) ComposeFunc[T]](<#func-pipe>)
  - [func Reduce[T any](list []T, fn func(prev T, next T) T) ComposeFunc[T]](<#func-reduce>)
- [type MapperFunc](<#type-mapperfunc>)
- [type PredicateFunc](<#type-predicatefunc>)


## func [Chunk](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L114>)

```go
func Chunk[T any](list []T, chunkSize int) [][]T
```

Chunk \- creates a new nested slice with slice elements chunked

## func [Difference](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L129>)

```go
func Difference[T comparable](lists ...[]T) []T
```

Difference \- Creates an array of array values not included in the other given arrays.

## func [Every](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L81>)

```go
func Every[T any](list []T, fn PredicateFunc[T]) bool
```

Every \- tests whether all elements in the array pass the test implemented by the provided function.

## func [Filter](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L4>)

```go
func Filter[T any](list []T, fn PredicateFunc[T]) []T
```

Filter \- return a new list of elements that return true on the predicate func.

## func [Find](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L69>)

```go
func Find[T any](list []T, fn PredicateFunc[T]) (T, bool)
```

Find \- returns the first element in the provided array that satisfies the provided testing function. If item is not found return nil value.

## func [ForEach](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L26>)

```go
func ForEach[T comparable](list []T, fn func(input T))
```

ForEach \- iterates over the list and invokes the function on the element.

## func [Map](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L16>)

```go
func Map[T comparable, K any](list []T, fn MapperFunc[T, K]) []K
```

Map \- creates a new array populated with the results of calling a provided function on every element in the calling array.

## func [MapKeys](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L4>)

```go
func MapKeys[T comparable, K any](obj map[T]K) []T
```

Keys \- return map's keys

## func [MapOmitKeys](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L23>)

```go
func MapOmitKeys[T comparable, K any](obj map[T]K, omits ...T) map[T]K
```

MapOmitKeys \- returns a partial copy of an object omitting the keys specified. If the key does not exist, the property is ignored.

## func [MapPickKeys](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L32>)

```go
func MapPickKeys[T comparable, K any](obj map[T]K, picks ...T) map[T]K
```

MapPickKeys\- Returns a partial copy of an object containing only the keys specified. If the key does not exist, the property is ignored.

## func [MapValues](<https://github.com/code-gorilla-au/mewl/blob/main/maps.go#L13>)

```go
func MapValues[T comparable, K any](obj map[T]K) []K
```

MapValues \- return map's values

## func [Reverse](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L105>)

```go
func Reverse[T comparable](list []T) []T
```

Reverse \- return slice in reverse order

## func [Some](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L174>)

```go
func Some[T any](list []T, fn PredicateFunc[T]) bool
```

Some \- Checks if predicate returns truthy for any element of a list. Iteration is stopped once predicate returns truthy

## func [Union](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L49>)

```go
func Union[T comparable](lists ...[]T) []T
```

Union \- merges two lists into a slice with no duplicates composed of the elements of each list.

## func [Unique](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L33>)

```go
func Unique[T comparable](list []T) []T
```

Unique \- return unique items from a provided list

## func [Without](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L158>)

```go
func Without[T comparable](list []T, omit ...T) []T
```

Without \- Creates an array excluding all given values

## type [ComposeFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L4>)

ComposeFunc \- function that receives an input and returns an input of the same type.

```go
type ComposeFunc[T any] func(T) T
```

### func [Before](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L30>)

```go
func Before[T any](count int, fn ComposeFunc[T]) ComposeFunc[T]
```

### func [Once](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L16>)

```go
func Once[T any](fn ComposeFunc[T]) ComposeFunc[T]
```

Once \- Creates a function that is restricted to invoking func once. Repeat calls to the function return the value of the first invocation

### func [Pipe](<https://github.com/code-gorilla-au/mewl/blob/main/functions.go#L4>)

```go
func Pipe[T any](fns ...ComposeFunc[T]) ComposeFunc[T]
```

Pipe \- left to right function composition

### func [Reduce](<https://github.com/code-gorilla-au/mewl/blob/main/array.go#L94>)

```go
func Reduce[T any](list []T, fn func(prev T, next T) T) ComposeFunc[T]
```

Reduce \- executes a user\-supplied "reducer" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value

## type [MapperFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L10>)

MapperFunc \- transform function that receives an input and returns a new type.

```go
type MapperFunc[T any, K any] func(item T) K
```

## type [PredicateFunc](<https://github.com/code-gorilla-au/mewl/blob/main/types.go#L7>)

PredicateFunc \- function that receives an input and returns a boolean value.

```go
type PredicateFunc[T any] func(item T) bool
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)


<!-- gomarkdoc:embed:end -->